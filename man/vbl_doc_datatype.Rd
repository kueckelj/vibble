% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/0-utils-internal.R
\name{vbl_doc_datatype}
\alias{vbl_doc_datatype}
\alias{.infer_datatype}
\alias{.infer_datatype.default}
\alias{.infer_datatype.vbl}
\title{Infer NIfTI datatype from vibble content.}
\usage{
.infer_datatype(x, ...)

\method{.infer_datatype}{default}(x, ...)

\method{.infer_datatype}{vbl}(x, var, ...)
}
\arguments{
\item{x}{An object for which a method has been defined.}

\item{var}{Character scalar. Name of a non-ccs variable in \code{vbl} whose content
is to be written into a NIfTI.}

\item{strict}{Logical. If \code{TRUE}, fail fast on empty, ambiguous, or unsupported
inputs instead of falling back to a conservative default.}

\item{na_rm}{Logical. If \code{TRUE}, ignore \code{NA} values when inferring the datatype.}
}
\value{
An integer scalar giving the NIfTI datatype code (e.g. \code{2}, \code{4}, \code{16}).
}
\description{
\code{.infer_datatype()} infers an appropriate NIfTI \code{datatype} code for a single
non-ccs variable in a vibble before writing it to disk.
}
\details{
The inference is based on the \emph{actual values} of the variable, not on metadata.
\code{NA} values are ignored by default.

The decision logic is:
\itemize{
\item \strong{mask}: logical values or integer values restricted to \verb{\{0,1\}}
→ \code{datatype = 2} (uint8)
\item \strong{categorical}: integer-like values beyond binary
→ \code{datatype = 2} (uint8) if ≤255 unique labels,
→ \code{datatype = 4} (int16) otherwise
\item \strong{numeric}: non–integer-like values
→ \code{datatype = 16} (float32)
}

In non-strict mode, ambiguous or empty inputs fall back to \code{datatype = 16}.
In strict mode, unsupported or ambiguous inputs raise an error.
}
\keyword{internal}
