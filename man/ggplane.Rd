% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ggvibble.R
\name{ggplane}
\alias{ggplane}
\title{Build a 2D ggplot representation of voxel data}
\usage{
ggplane(
  vbl,
  var = NULL,
  slices = vbl_def(),
  plane = vbl_def(),
  crop = NULL,
  expand = 0.1,
  offset_col = 0,
  offset_row = 0,
  zstack = "asc",
  ncol = NULL,
  nrow = NULL,
  .cond = NULL,
  .by = NULL,
  ...
)
}
\arguments{
\item{vbl}{A \link[=vbl_doc_vbl]{vibble}.}

\item{var}{Character scalar. Name of the background variable to plot.
If \code{NULL}, no background layer is drawn.}

\item{slices}{Integer vector. Slice indices in the specified anatomical
\code{plane} to be included in the plot. Defaults to using \link{slices_mid}\verb{()}.}

\item{plane}{Character scalar. The anatomical orientation, one of \emph{'sag', 'axi' or 'cor'}.
Defaults to the \link[=vbl_doc_defaults]{global default plane}.}

\item{crop}{Defines the \link[=vbl_doc_ref_bb]{data bounding box}
applied to all slices in native (pre-offset) coordinates.

\itemize{
\item{\code{NULL}: }{ No cropping.}
\item{\code{limit}: }{ A single spatial \link[=is_limit]{limit} recycled for both \code{col} and \code{row}.}
\item{\code{bb2D}: }{ A \link[=is_bb2D]{2D bounding box} with separate limits for \code{col} and \code{row}.}
}

When the supplied bounding box is smaller than the slice extents, only voxels
inside this region are retained, giving \code{crop} a filtering effect.}

\item{expand}{An \link[=is_expand]{expand} specification applied to the col/row limits
of \code{crop} \strong{after} interpretation and potential filtering to set the \link[=vbl_doc_ref_bb]{screen bounding box}.}

\item{offset_col, offset_row}{Numeric scalars. Offsets applied per slice along
the \code{col} and \code{row} axes, which can be specified as either \strong{absolute} or \strong{relative} values:

\itemize{
\item{Absolute:}{ Integers, or numeric values wrapped in \code{as_abs()}, are
interpreted as absolute offsets in data coordinates.}
\item{Relative:}{ Numeric values, or values wrapped in \code{as_rel()}, are
interpreted as offsets relative to the \link[=data_bb]{screen bounding box}.}
}}

\item{zstack}{Character scalar. Controls the stacking order of slices along
the slice axis when multiple slices are displayed with an offset-layout.

\itemize{
\item{\code{"asc"}: }{ Slices with lower slice indices are drawn first and may be
occluded by higher-index slices in overlapping offset layouts.}
\item{\code{"desc"}: }{ Slices with higher slice indices are drawn first and may be
occluded by lower-index slices in overlapping offset layouts.}
}}

\item{ncol, nrow}{Passed to \link{facet_wrap()} in no-offset layouts.}

\item{.cond}{Optional. A logical filter expression evaluated on the constructed
\code{vbl2D}. The expression is evaluated via \link[rlang:args_data_masking]{data-masking} semantics.}

\item{.by}{A \link[dplyr:dplyr_tidy_select]{tidy-selection} of columns to
group by before applying the filtering logic of \code{.cond}.}

\item{...}{Additional arguments forwarded to the fill scale functions.}
}
\value{
A \link{ggvibble} object.
}
\description{
Initializes a 2D visualization of voxel data by selecting slices in a
specified anatomical plane. Returns a \code{ggvibble} container that can be
complemented with additional ggvibble layers.
}
\details{
\code{ggplane()} constructs a \code{ggvibble} in a small number of explicit steps.

\itemize{
\item{1. Build 2D representation: } Converts \code{vbl} to \code{vbl2D} via \link{vibble2D}()
by selecting \code{plane} and \code{slices} and applying \code{crop} and \code{expand}.
\item{2. Filter plotted voxels: } Applies \code{.cond} (and optional grouping via \code{.by})
using \code{.filter_layer()} to determine which voxels are shown.
\item{3. Order slices: } Optionally arranges \code{vbl2D} by slice index via \code{zstack}
to control draw order when slices overlap in offset layouts.
\item{4. Apply offsets: } Applies \code{offset_col} and \code{offset_row} via \code{apply_offset()}.
If both offsets are zero and multiple slices are present, slices are displayed in
separate panels using \code{facet_wrap(. ~ slice)}; otherwise slices are drawn in one
shared panel.
\item{5. Store plot specification: } Stores the resulting \code{vbl2D}, base plotting
arguments, and an initially empty layer list in a \code{ggvibble} container.
\item{6. Determine plot limits and expansion: } The plotting bounding box is
derived from the spatial extent of the displayed voxels. Expansion is applied
in absolute image-space units, choosing the smallest symmetric expansion across
axes to preserve aspect ratio. Final limits are enforced via \code{coord_equal()}
with \code{expand = FALSE}.
}

The final ggplot is created when the object is printed or plotted. The base plot
uses \code{geom_raster()} in image space with \code{scale_y_reverse()} and \code{coord_equal()}.

Numeric variables are mapped with \link{scale_fill_numeric}() (via \code{clrsp}).
Non-numeric variables are mapped with \link{scale_fill_categorical}() (via \code{clrp}).
Logical mask variables are coerced to a factor with levels \code{c("TRUE", "FALSE")}.
For binary mask overlays, use \link{layer_mask}().
}
\seealso{
Details about the \link[=vbl_doc_ggvibble]{ggvibble framework}
and \link[=vbl_doc_ggvibble_operators]{ggplot2 compatibility}.
}
