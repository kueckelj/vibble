% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ggvibble.R
\name{ggplane}
\alias{ggplane}
\title{Build a 2D ggplot representation of voxel data}
\usage{
ggplane(
  vbl,
  var,
  plane,
  slices,
  screen_bb = NULL,
  expand = 0.1,
  offset_col = 0,
  offset_row = 0,
  zstack = "desc",
  layout = NULL,
  clrp = vbl_opts("clrp"),
  clrsp = vbl_opts("clrsp"),
  interpolate = vbl_opts("interpolate"),
  verbose = vbl_opts("verbose"),
  .cond = NULL,
  .by = NULL,
  ...
)
}
\arguments{
\item{vbl}{A \link[=vbl_doc_vbl]{vibble}.}

\item{var}{Character scalar naming the variable to plot.}

\item{plane}{Character scalar. The anatomical orientation. Valid options are \emph{c('sag', 'axi', 'cor')}.}

\item{slices}{Integer vector. Slice indices in the specified anatomical
\code{plane} to be included in the plot.}

\item{screen_bb}{\code{bb2D}, \code{limit}, or \code{NULL}. Bounding box defining the common
\link[=vbl_doc_limits_2D]{screen window} applied to all slices in native (pre-offset) coordinates.

\itemize{
\item{\code{NULL}: }{ Screen window defaults to the global data extent.}
\item{\code{limit}: }{ A single spatial \link[=is_limit]{limit} recycled for both \code{col} and \code{row}.}
\item{\code{bb2D}: }{ A \link[=is_bb2D]{2D bounding box} with separate limits for \code{col} and \code{row}.}
}

When the supplied bounding box is smaller than the slice extents, only voxels
inside this region are retained, giving \code{screen_bb} a filtering effect.}

\item{expand}{An \link[=is_expand]{expand} specification applied to the col/row limits
of \code{screen_bb} \strong{after} interpretation and potential filtering.}

\item{offset_col, offset_row}{Numeric scalars. Offsets applied per slice along
the \code{col} and \code{row} axes, which can be specified as either \strong{absolute} or \strong{relative} values:

\itemize{
\item{Absolute:}{ Integers, or numeric values wrapped in \code{as_abs()}, are
interpreted as absolute offsets in data coordinates.}
\item{Relative:}{ Numeric values, or values wrapped in \code{as_rel()}, are
interpreted as offsets relative to the current plotting limits.}
}

If both, \code{offset_col} and \code{offset_row} are zero, each slice is displayed in its
own panel using \code{facet_wrap()}, arranged according to \code{layout}.}

\item{zstack}{Character scalar. Controls the stacking order of slices along
the slice axis when multiple slices are displayed with an offset-layout.

\itemize{
\item{\code{"asc"}: }{ Slices with lower slice indices are drawn first and may be
occluded by higher-index slices in overlapping offset layouts.}
\item{\code{"desc"}: }{ Slices with higher slice indices are drawn first and may be
occluded by lower-index slices in overlapping offset layouts.}
}}

\item{layout}{Optional numeric vector of length two specifying \code{c(ncol, nrow)} for \code{facet_wrap()}
when neither of \code{offset_col} or \code{offset_row} differs from 0.}

\item{clrp}{Character scalar specifying the categorical palette.
Must be one of \code{\link{clrp_opts_vec}()}. Defaults to \code{vbl_opts("clrp")}.}

\item{clrsp}{Character scalar specifying the numeric color palette used in \link{scale_fill_numeric}().}

\item{interpolate}{Logical scalar indicating whether to interpolate raster tiles.}

\item{verbose}{Logical. If \code{TRUE}, informative messages are printed in the
console.}

\item{.cond}{Optional. An additional logical filter expression that determines the specific
voxels plotted with \code{ggplane()} and passed to added \link[vbl_doc_vbl_layer]{layers}. \if{html}{\out{<br>}}

The expression is evaluated via \link[rlang:args_data_masking]{data-masking} semantics.}

\item{.by}{A \link[dplyr:dplyr_tidy_select]{tidy-selection} of columns to
group by before applying the filtering logic of \code{.cond}.}

\item{...}{Additional arguments forwarded to the scale functions controlling the fill aesthetic.}
}
\value{
A \link{ggvibble} object.
}
\description{
Build a 2D visualization of voxel data by selecting slices in a
specified anatomical plane.
}
\details{
\code{ggplane()} converts \code{vbl} to a \code{vbl2D} object via \link{vibble2D}().
It then stores plotting arguments and returns a \code{ggvibble} container. If multiple slices are present
and the object is not offset, slices are arranged using \link{facet_wrap}() with the requested \code{layout}.

Numeric variables are plotted with \link{scale_fill_numeric}() using \code{clrsp}. Non-numeric variables are
plotted with \link{scale_fill_label}() using \code{clrp}. Note, that in \code{ggplane()}, logical mask variables
are coerced to factors with levels \code{c("TRUE", "FALSE")} before plotting, for binary mask overlays see \link{layer_mask()}.
}
