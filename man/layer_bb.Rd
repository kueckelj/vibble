% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ggvibble-layers.R
\name{layer_bb}
\alias{layer_bb}
\alias{layer_bb_data}
\alias{layer_bb_plot}
\alias{layer_bb_screen}
\alias{layer_bb_slice}
\title{Add a data-driven 2D bounding-box}
\usage{
layer_bb(
  .cond = NULL,
  color = "red",
  alpha = 0.9,
  linetype = "solid",
  linewidth = 0.5,
  expand = as_abs(0.5),
  label = TRUE,
  slices = NULL,
  .by = "slice",
  ...
)

layer_bb_data(
  color = "orange",
  alpha = 0.9,
  fill = NA,
  linetype = "solid",
  linewidth = 0.5,
  label = TRUE,
  slices = NULL,
  ...
)

layer_bb_plot(
  color = "forestgreen",
  alpha = 0.9,
  fill = NA,
  linetype = "solid",
  linewidth = 0.5,
  label = TRUE,
  ...
)

layer_bb_screen(
  color = "steelblue",
  alpha = 0.9,
  fill = NA,
  linetype = "solid",
  linewidth = 0.5,
  label = TRUE,
  slices = NULL,
  ...
)

layer_bb_slice(
  color = "purple",
  alpha = 0.9,
  fill = NA,
  linetype = "solid",
  linewidth = 0.5,
  label = TRUE,
  slices = NULL,
  ...
)
}
\arguments{
\item{.cond}{A logical filter expression that determines the specific
voxels included in the content of this layer. The expression is evaluated via
\link[rlang:args_data_masking]{data-masking} semantics with the 2D vibble passed
into this layer by \code{ggvibble}(). See \link[=vbl_doc_cond]{Details}.}

\item{color}{Color of the bounding-box outline.}

\item{linetype}{Defines the line pattern. Supported values:
\itemize{
\item {Named types:}{ c("solid", "dashed", "dotted", "dotdash", "longdash", "twodash") }
\item {Numeric codes:}{ c("0", "1", "2", "3", "4", "5", "6") }
\item {Custom:}{ c("12", "1F", "F0F0") as examples of hexadecimal dash patterns}
}}

\item{linewidth}{Numeric scalar. Controlls the thickness of drawn lines.}

\item{label}{Logical or character scalar. Controls the legend label with which
the color of this layer is associated with in the legend.

\itemize{
\item{Character: } Uses the provided value as the label.
\item{\code{TRUE}: } Uses the functionâ€™s default to create the label.
\item{\code{FALSE}: } Does not include the color in the legend.
}}

\item{slices}{Optional. Numeric vector of \link[=is_slice]{slice numbers} used to
restrict the content of this layer to specific slices. If \code{NULL}, no restriction
is applied and the function considers all slices, as denoted in the \link{ggvibble}()
container.}

\item{.by}{A \link[dplyr:dplyr_tidy_select]{tidy-selection} of columns to
group by before applying the filtering logic of \code{.cond}. Defaults to \emph{'slice'}.}

\item{...}{Additional arguments passed to \link{geom_rect}().}

\item{fill}{Fill of the bounding-box.}
}
\value{
A \code{ggvibble_layer} object containing the supplied function. When
added to a \code{ggvibble}, the function is executed and its returned layers are
inserted into the plot.
}
\description{
Draw a rectangular bounding box around the extent of voxels
or \link[=vbl_doc_ref_bb]{2D reference bounding boxes}.
}
\details{
\code{layer_bb()} computes and visualizes a 2D bounding box for voxels based on the
minimal and maximal \code{col} and \code{row} coordinates where \code{.cond} evaluates to \code{TRUE}.
In all cases, the graphical rendering is handled by \link{geom_rect}().

Bounding boxes are \strong{always} computed slicewise.
}
