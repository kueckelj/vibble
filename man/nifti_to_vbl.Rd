% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/vibble-io-nifti.R
\name{nifti_to_vbl}
\alias{nifti_to_vbl}
\title{Convert a NIfTI image into a vibble.}
\usage{
nifti_to_vbl(
  nifti,
  var = "value",
  lut = NULL,
  ordered = FALSE,
  add_id = FALSE,
  rm0 = TRUE,
  verbose = TRUE,
  ...
)
}
\arguments{
\item{nifti}{A NIfTI object or a character path to a \code{.nii} or \code{.nii.gz} file.}

\item{var}{Character. Name of the voxel-wise variable to extract and store as the main
variable in the vibble.}

\item{lut}{Either a file path to a LUT, character vector of labels or a data.frame with integer indices
and character labels.}

\item{ordered}{Logical or \code{NULL}. If a lookup table is provided, controls whether the
resulting labeled factor is ordered. If \code{NULL}, ordering defaults to
\code{FALSE}.}

\item{add_id}{Logical. If \code{TRUE}, add a unique voxel ID column.}

\item{rm0}{Logical. If \code{TRUE}, remove voxels with value 0 from the resulting
vibble. Replaces the deprecated argument \code{black_rm}.}

\item{...}{Additional arguments; currently supports the deprecated argument
\code{black_rm}.}
}
\value{
A \link{vibble} containing voxel coordinates, the extracted voxel variable,
and metadata attributes describing orientation, coordinate limits, lookup
table usage, and per-variable summaries.
}
\description{
Create a \link{vibble} from a NIfTI object or file path by melting the voxel
data into long format, assigning coordinate axes, applying orientation
corrections, converting variable types, and optionally applying a lookup
table (LUT), removing zero-valued voxels, and adding voxel IDs.
}
\details{
The function accepts either a NIfTI object or a character file path. When a
path is supplied, the file is read without reorientation. If the original
NIfTI object has \code{@reoriented == TRUE}, a warning is issued because
voxel orientation may be unreliable.

Coordinate directions are extracted from the NIfTI header via
\code{RNifti::orientation()}. Axes are renamed to \code{x}, \code{y},
\code{z} according to the package's canonical coordinate mapping
(\code{ccs_orientation_mapping}). Axes that point in opposite anatomical
directions relative to the desired LIP convention are flipped.

The voxel values of \code{var} are inspected and converted:
\itemize{
\item binary 0/1 values → logical
\item any other non-numeric values → factor (if not already), then numeric
(unless processed by a LUT)
}

If \code{lut} is supplied and the variable appears to represent labeled
classes, the lookup table is applied via \code{map_lut()}. Otherwise the
variable is left numeric with a message (depending on \code{verbose}).

The vibble is stored with class \code{"vbl"} and the following attributes:
\itemize{
\item \code{orientation_orig}: orientation string extracted from the NIfTI object.
\item \code{ccs_mapping}: canonical voxel-to-axis mapping (currently fixed as LIP).
\item \code{ccs_limits}: coordinate limits for \code{x}, \code{y}, \code{z}.
\item \code{nifti}: the NIfTI object with its data array emptied, retained
for metadata compatibility.
\item \code{var_smr}: variable summary list created by \code{summarize_var()}.
}

If \code{rm0 = TRUE}, voxels with value 0 are removed. If \code{add_id = TRUE},
a unique voxel ID column is added via \code{id_add()}.
}
\examples{
\dontrun{
# Basic usage
vbl <- nifti_to_vbl("t1_orig.nii.gz")

# With lookup table for labeled images
lut <- data.frame(index = 1:3, label = c("GM", "WM", "CSF"))
seg_vbl <- nifti_to_vbl("seg_regMNI.nii.gz", var = "tissue", lut = lut)

# Remove background voxels and add IDs
vbl <- nifti_to_vbl("mask.nii.gz", rm0 = TRUE, add_id = TRUE)
}

}
