% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/vibble-doc.R
\name{vbl_doc_ggvibble}
\alias{vbl_doc_ggvibble}
\title{Plotting voxel data with ggvibble}
\description{
ggvibble provides a user-oriented interface for visualizing voxel-based medical
imaging data stored as tidy data. It allows users to create 2D slice-based
plots that behave like ggplot2 objects, while handling voxel-specific details
such as slicing, spatial layout, layer ordering, and multiple color scales
automatically.
}
\details{
From a user perspective, ggvibble works similarly to ggplot2:

\itemize{
\item A plot is initialized from a \link{vibble} using \link{ggplane}().
\item Additional visual elements are added using the \code{+} operator.
\item The plot is rendered automatically when printed.
}

Internally, ggvibble separates plotting into three steps, but users usually do
not need to be aware of this:

\itemize{
\item{Data preparation}: {Voxel data are converted to a 2D representation
(\code{vbl2D}) by selecting an anatomical plane and one or more slices.}

\item{Plot specification}: {A \code{ggvibble} object stores the prepared data,
base plotting options, and a list of layers added by the user.}

\item{Rendering}: {The final ggplot object is built lazily when the plot is
printed, ensuring consistent layer ordering and correct legend handling.}
}

Users can think of ggvibble layers as semantic plotting actions such as
"show voxel intensities", "overlay a mask", or "draw region outlines".
The internal ordering of layers (e.g. raster first, annotations last) is
handled automatically and does not depend on the order in which layers are
added.
}
\note{
ggvibble is designed to remove common sources of friction when plotting voxel
data (slice selection, raster alignment, scale conflicts), while remaining
familiar to users who already know ggplot2.
}
\section{Basic usage}{

The plot is initialized with \link{ggplane}() for a set of slices. While the variable
used for the coloring should be an intensity like T1, FLAIR or T2, data-driven variables
like masks or categorical labels can also be used.
\preformatted{
vbl <- example_vbl()

# start with an intensity
p <-
 ggplane(
   vbl = vbl,
   var = "t1",
   plane = "axi",
   slices = c(90, 100, 110),
   clrsp = c("black", "white")
 )

 p

 # start with categorical label data
 p_cat <-
   ggplane(
    vbl = vbl,
    var = "macro",
    plane = "axi",
    slices = c(90, 100, 110),
    clrp = "default"
    )

 p_cat

}
}

\section{Adding layers}{

Similar to ggplot2, ggvibbles are rendered during printing. So \code{p} itself is
a lightweight container with data and instructions that can be complemented
with additional layers. These layers draw data and layout instructions from
the \code{ggplane()} call.

\preformatted{
p_with_layers <- p +
  layer_mask(.cond = tumor, color = "red", opacity = 0.6) +
  layer_outline(.cond = tumor, color = "red") +
  layer_labels(var = "macro")

p_with_layers

}
}

\section{ggplot2 compatibility}{

A ggvibble plot can be treated like a ggplot object \strong{after explicit building} with
\link{as_ggplot}(). Standard ggplot2 themes and modifications can be added directly:

\preformatted{

 ggp <- as_ggplot(p)

 ggp + ggplot2::theme_void()

}
}

\seealso{
\link{ggplane}(),
\link{layer_mask}(),
\link{layer_outline}(),
\link{layer_labels}(),
\link{as_ggplot}()
}
